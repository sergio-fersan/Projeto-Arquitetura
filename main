ORG 0000H
LJMP INICIO

ORG 0100H
INICIO:
    MOV P1, #00H      ; Inicializa os LEDs (P1.0 e P1.1) apagados
    MOV 20H, #00H     ; Contador de dígitos digitados (endereço 20H)
    MOV 21H, #00H     ; Dígito 1 da senha armazenado (endereço 21H)
    MOV 22H, #00H     ; Dígito 2 da senha armazenado (endereço 22H)
    MOV 23H, #00H     ; Dígito 3 da senha armazenado (endereço 23H)
    MOV 24H, #00H     ; Dígito 4 da senha armazenado (endereço 24H)
    
    ; Definir a senha (exemplo: 1-2-3-4)
    MOV 25H, #01H     ; Senha dígito 1 (endereço 25H)
    MOV 26H, #02H     ; Senha dígito 2 (endereço 26H)
    MOV 27H, #03H     ; Senha dígito 3 (endereço 27H)
    MOV 28H, #04H     ; Senha dígito 4 (endereço 28H)
	MOV A, #0FFH

MAIN_LOOP:
    CALL TECLADO      ; Chama a rotina do teclado
    CJNE A, #0FFH, PROCESS_KEY ; Se uma tecla foi pressionada (A != 0xFF)
    SJMP MAIN_LOOP    ; Se não, continua no loop

PROCESS_KEY:
    ; Verifica se é a tecla * (confirmar senha) - assumindo que * é a tecla 10
    CJNE A, #0AH, NOT_STAR ; Se não for *, verifica dígitos
    ; Tecla * pressionada - verificar senha
    MOV A, 20H        ; Carrega contador de dígitos
    CJNE A, #04H, WRONG_PASSWORD ; Se não digitou 4 dígitos, senha errada
    
    ; Compara cada dígito da senha
    MOV A, 21H        ; Primeiro dígito digitado
    CJNE A, 25H, WRONG_PASSWORD ; Compara com primeiro dígito da senha
    MOV A, 22H        ; Segundo dígito digitado
    CJNE A, 26H, WRONG_PASSWORD
    MOV A, 23H        ; Terceiro dígito digitado
    CJNE A, 27H, WRONG_PASSWORD
    MOV A, 24H        ; Quarto dígito digitado
    CJNE A, 28H, WRONG_PASSWORD
    
    ; Senha correta
    SETB P1.1         ; Acende LED verde (senha correta)
    CLR P1.0          ; Apaga LED vermelho
    CALL DELAY        ; Espera um tempo
    CLR P1.1          ; Apaga LED verde
    SJMP RESET_PASSWORD ; Reinicia para nova tentativa

WRONG_PASSWORD:
    SETB P1.0         ; Acende LED vermelho (senha incorreta)
    CLR P1.1          ; Apaga LED verde
    CALL DELAY        ; Espera um tempo
    CLR P1.0          ; Apaga LED vermelho
    
RESET_PASSWORD:
    MOV 20H, #00H     ; Reseta contador de dígitos
    MOV 21H, #00H     ; Limpa dígitos armazenados
    MOV 22H, #00H
    MOV 23H, #00H
    MOV 24H, #00H
    SJMP MAIN_LOOP    ; Volta para o loop principal

NOT_STAR:
    ; Verifica se é um dígito válido (0-9)
    CJNE A, #00H, CHECK_1
    MOV R2, #00H      ; Tecla 0 (armazena temporariamente em R2)
    SJMP VALID_DIGIT
CHECK_1:
    CJNE A, #01H, CHECK_2
    MOV R2, #01H      ; Tecla 1
    SJMP VALID_DIGIT
CHECK_2:
    CJNE A, #02H, CHECK_3
    MOV R2, #02H      ; Tecla 2
    SJMP VALID_DIGIT
CHECK_3:
    CJNE A, #03H, CHECK_4
    MOV R2, #03H      ; Tecla 3
    SJMP VALID_DIGIT
CHECK_4:
    CJNE A, #04H, CHECK_5
    MOV R2, #04H      ; Tecla 4
    SJMP VALID_DIGIT
CHECK_5:
    CJNE A, #05H, CHECK_6
    MOV R2, #05H      ; Tecla 5
    SJMP VALID_DIGIT
CHECK_6:
    CJNE A, #06H, CHECK_7
    MOV R2, #06H      ; Tecla 6
    SJMP VALID_DIGIT
CHECK_7:
    CJNE A, #07H, CHECK_8
    MOV R2, #07H      ; Tecla 7
    SJMP VALID_DIGIT
CHECK_8:
    CJNE A, #08H, CHECK_9
    MOV R2, #08H      ; Tecla 8
    SJMP VALID_DIGIT
CHECK_9:
    CJNE A, #09H, INVALID_KEY
    MOV R2, #09H      ; Tecla 9
    SJMP VALID_DIGIT

INVALID_KEY:
    LJMP MAIN_LOOP    ; Volta para o loop principal

VALID_DIGIT:
    ; Verifica se já digitou 4 dígitos
    MOV A, 20H
    CJNE A, #04H, STORE_CONTINUE
    LJMP MAIN_LOOP    ; Já tem 4 dígitos, ignora até *

STORE_CONTINUE:
    ; Armazena o dígito pressionado (está em R2)
    INC 20H           ; Incrementa contador de dígitos
    MOV A, 20H        ; Usa A como índice
    
    ; Determina onde armazenar o dígito
    CJNE A, #01H, NOT_FIRST
    MOV 21H, R2       ; Armazena primeiro dígito
    LJMP MAIN_LOOP

NOT_FIRST:
    CJNE A, #02H, NOT_SECOND
    MOV 22H, R2       ; Armazena segundo dígito
    LJMP MAIN_LOOP

NOT_SECOND:
    CJNE A, #03H, NOT_THIRD
    MOV 23H, R2       ; Armazena terceiro dígito
    LJMP MAIN_LOOP

NOT_THIRD:
    MOV 24H, R2       ; Armazena quarto dígito
    LJMP MAIN_LOOP

; Rotina de atraso
DELAY:
    MOV R7, #0FFH
DELAY_LOOP1:
    MOV R6, #0FFH
DELAY_LOOP2:
    DJNZ R6, DELAY_LOOP2
    DJNZ R7, DELAY_LOOP1
    RET

; Rotina do teclado
VOLTA:
CALL TECLADO
SJMP VOLTA

TECLADO:
MOV R0, #0CH ; clear R0 - the first key is key0

; scan row0
SETB P0.3 ; set row3
CLR P0.0 ; clear row0
CALL colScan ; call column-scan subroutine

; scan row1
SETB P0.0 ; set row0
CLR P0.1 ; clear row1
CALL colScan ; call column-scan subroutine

; scan row2
SETB P0.1 ; set row1
CLR P0.2 ; clear row2
CALL colScan ; call column-scan subroutine

; scan row3
SETB P0.2 ; set row2
CLR P0.3 ; clear row3
CALL colScan ; call column-scan subroutine
CJNE R0,#0CH,SAI
MOV A,#0FFH
SAI:
RET

colScan:
JNB P0.4, gotKey ; if col0 is cleared - key found
DEC R0 ; otherwise move to next key
JNB P0.5, gotKey ; if col1 is cleared - key found
DEC R0 ; otherwise move to next key
JNB P0.6, gotKey ; if col2 is cleared - key found
DEC R0 ; otherwise move to next key
RET ; return from subroutine - key not found
gotKey:
MOV A,R0
RET 
END
