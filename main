ORG 0000H
LJMP INICIO

ORG 0100H
INICIO:
    MOV P1, #00H      ; Inicializa os LEDs (P1.0 e P1.1) apagados
    MOV 20H, #00H     ; Contador de dígitos digitados (endereço 20H)
    MOV 21H, #00H     ; Dígito 1 da senha armazenado (endereço 21H)
    MOV 22H, #00H     ; Dígito 2 da senha armazenado (endereço 22H)
    MOV 23H, #00H     ; Dígito 3 da senha armazenado (endereço 23H)
    MOV 24H, #00H     ; Dígito 4 da senha armazenado (endereço 24H)
    
    ; Definir a senha (exemplo: 1-2-3-4)
    MOV 25H, #01H     ; Senha dígito 1 (endereço 25H)
    MOV 26H, #02H     ; Senha dígito 2 (endereço 26H)
    MOV 27H, #03H     ; Senha dígito 3 (endereço 27H)
    MOV 28H, #04H     ; Senha dígito 4 (endereço 28H)

MAIN_LOOP:
    CALL TECLADO      ; Chama a rotina do teclado
    CJNE A, #0FFH, PROCESS_KEY ; Se uma tecla foi pressionada (A != 0xFF)
    SJMP MAIN_LOOP    ; Se não, continua no loop

PROCESS_KEY:
    ; Verifica se é a tecla * (confirmar senha) - assumindo que * é a tecla 10
    CJNE A, #0AH, NOT_STAR ; Se não for *, verifica dígitos
    ; Tecla * pressionada - verificar senha
    MOV A, 20H        ; Carrega contador de dígitos
    CJNE A, #04H, WRONG_PASSWORD ; Se não digitou 4 dígitos, senha errada
    
    ; Compara cada dígito da senha
    MOV A, 21H        ; Primeiro dígito digitado
    CJNE A, 25H, WRONG_PASSWORD ; Compara com primeiro dígito da senha
    MOV A, 22H        ; Segundo dígito digitado
    CJNE A, 26H, WRONG_PASSWORD
    MOV A, 23H        ; Terceiro dígito digitado
    CJNE A, 27H, WRONG_PASSWORD
    MOV A, 24H        ; Quarto dígito digitado
    CJNE A, 28H, WRONG_PASSWORD
    
    ; Senha correta
    SETB P1.1         ; Acende LED verde (senha correta)
    CLR P1.0          ; Apaga LED vermelho
    CALL DELAY        ; Espera um tempo
    CLR P1.1          ; Apaga LED verde
    SJMP RESET_PASSWORD ; Reinicia para nova tentativa

WRONG_PASSWORD:
    SETB P1.0         ; Acende LED vermelho (senha incorreta)
    CLR P1.1          ; Apaga LED verde
    CALL DELAY        ; Espera um tempo
    CLR P1.0          ; Apaga LED vermelho
    
RESET_PASSWORD:
    MOV 20H, #00H     ; Reseta contador de dígitos
    MOV 21H, #00H     ; Limpa dígitos armazenados
    MOV 22H, #00H
    MOV 23H, #00H
    MOV 24H, #00H
    SJMP MAIN_LOOP    ; Volta para o loop principal

NOT_STAR:
    ; Verifica se é um dígito válido (0-9)
    CJNE A, #00H, CHECK_1
    MOV A, #00H       ; Tecla 0
    SJMP STORE_DIGIT
CHECK_1:
    CJNE A, #01H, CHECK_2
    MOV A, #01H       ; Tecla 1
    SJMP STORE_DIGIT
CHECK_2:
    CJNE A, #02H, CHECK_3
    MOV A, #02H       ; Tecla 2
    SJMP STORE_DIGIT
CHECK_3:
    CJNE A, #03H, CHECK_4
    MOV A, #03H       ; Tecla 3
    SJMP STORE_DIGIT
CHECK_4:
    CJNE A, #04H, CHECK_5
    MOV A, #04H       ; Tecla 4
    SJMP STORE_DIGIT
CHECK_5:
    CJNE A, #05H, CHECK_6
    MOV A, #05H       ; Tecla 5
    SJMP STORE_DIGIT
CHECK_6:
    CJNE A, #06H, CHECK_7
    MOV A, #06H       ; Tecla 6
    SJMP STORE_DIGIT
CHECK_7:
    CJNE A, #07H, CHECK_8
    MOV A, #07H       ; Tecla 7
    SJMP STORE_DIGIT
CHECK_8:
    CJNE A, #08H, CHECK_9
    MOV A, #08H       ; Tecla 8
    SJMP STORE_DIGIT
CHECK_9:
    CJNE A, #09H, INVALID_KEY
    MOV A, #09H       ; Tecla 9
    SJMP STORE_DIGIT

INVALID_KEY:
    LJMP MAIN_LOOP    ; Volta para o loop principal

STORE_DIGIT:
    ; Verifica se já digitou 4 dígitos
    MOV R1, 20H       ; Carrega contador de dígitos
    CJNE R1, #04H, STORE_CONTINUE
    LJMP MAIN_LOOP    ; Já tem 4 dígitos, ignora até *

STORE_CONTINUE:
    ; Armazena o dígito pressionado (já está em A)
    INC 20H           ; Incrementa contador de dígitos
    MOV R1, 20H       ; Usa R1 como índice temporário
    
    ; Determina onde armazenar o dígito
    CJNE R1, #01H, NOT_FIRST
    MOV 21H, A        ; Armazena primeiro dígito
    LJMP MAIN_LOOP

NOT_FIRST:
    CJNE R1, #02H, NOT_SECOND
    MOV 22H, A        ; Armazena segundo dígito
    LJMP MAIN_LOOP

NOT_SECOND:
    CJNE R1, #03H, NOT_THIRD
    MOV 23H, A        ; Armazena terceiro dígito
    LJMP MAIN_LOOP

NOT_THIRD:
    MOV 24H, A        ; Armazena quarto dígito
    LJMP MAIN_LOOP

; Rotina de atraso (ajuste conforme necessário)
DELAY:
    MOV R7, #0FFH
DELAY_LOOP1:
    MOV R6, #0FFH
DELAY_LOOP2:
    DJNZ R6, DELAY_LOOP2
    DJNZ R7, DELAY_LOOP1
    RET

; Rotina do teclado (a mesma que você forneceu)
TECLADO:
    MOV R0, #0CH      ; clear R0 - the first key is key0

    ; scan row0
    SETB P0.3         ; set row3
    CLR P0.0          ; clear row0
    CALL colScan      ; call column-scan subroutine

    ; scan row1
    SETB P0.0         ; set row0
    CLR P0.1          ; clear row1
    CALL colScan      ; call column-scan subroutine

    ; scan row2
    SETB P0.1         ; set row1
    CLR P0.2          ; clear row2
    CALL colScan      ; call column-scan subroutine

    ; scan row3
    SETB P0.2         ; set row2
    CLR P0.3          ; clear row3
    CALL colScan      ; call column-scan subroutine
    CJNE R0,#0CH,SAI
    MOV A,#0FFH
SAI:
    RET

colScan:
    JNB P0.4, gotKey  ; if col0 is cleared - key found
    DEC R0            ; otherwise move to next key
    JNB P0.5, gotKey  ; if col1 is cleared - key found
    DEC R0            ; otherwise move to next key
    JNB P0.6, gotKey  ; if col2 is cleared - key found
    DEC R0            ; otherwise move to next key
    RET               ; return from subroutine - key not found
gotKey:
    MOV A,R0
    RET

END
